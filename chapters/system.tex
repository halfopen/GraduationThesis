\chapter{面向日常健康的面诊系统设计与实现}

通过对面诊系统的调研以及上一章节的用户研究，本文发现日常健康场景下的面诊技术的使用存在实用性、技术敏感性、文化敏感性等等问题，这里不再赘述。
针对这些问题，本文提出了对应的解决方案。同时，考虑到面诊技术发展迅速，目前的面诊系统设计都相对特异化，
本文希望提出一个相对统一的解决方案，提供标准的模型管理与接入方法，因此本文设计的面向日常健康管理的面诊系统需要着重解决以下几点问题：
\begin{itemize}
    \item 系统交互问题：(1)日常健康场景下用户使用舌诊如何避免尴尬？(2)繁琐的使用流程影响长期使用。(3)专业术语带来的理解问题。(4)系统准确度带来的信赖问题。(5)诊断结果带来的情绪问题。
    \item 技术敏感性问题：(1)屏蔽移动设备间的差异性，降低设备要求。(2)系统稳定性问题。(3)模型管理与接入问题。
\end{itemize}

本章将从交互设计和系统设计方面阐述这些问题分别是如何解决的，其中设计策略实现部分着重解决系统交互问题，系统设计方面着重解决技术敏感性问题。
为保持与绪论中工作内容顺序的一致性，本章在内容安排上先介绍设计两个策略的实现，之后介绍总体系统设计，最后分模块介绍总体设计中的模型池和服务端的详细设计。

\section{设计策略实现1：日常可用性设计}
% 介绍原设计存在的缺点

% 在之前的研究中本文发现，目前的面诊交互设计在用户日常使用过程中存在以下问题：
\subsection{设计策略}
在之前的研究中本文发现，目前的面诊交互设计在用户日常使用过程中存在以下具体的可用性问题：
\begin{itemize}
    \item 日常健康场景下用户使用舌诊如何避免尴尬？
    与诊所环境不同，由于文化敏感性的问题，大部分中国人认为公共场合伸出舌头是非常不雅观的行为；部分用户也因为各种原因不愿意在非私人空间下拍自己的面部。这种设计对用户的日常使用产生了非常大的阻碍。
    \item 繁琐的使用流程影响长期使用。
    在用户持续使用的时候，用户每次诊断和上一次通常没有太大的变化。每次让用户重复相同的操作不仅非常费时，而且影响使用的积极性。
\end{itemize}

根据第三章增加日常可用性的思路，本文在设计实现过程中，邀请用户在日常使用的过程中参与迭代过程，最后实现了可用性设计原型。

\subsection{可用性设计实现}

\begin{figure}[h]
    \centering
    \subfigure[原型入口]{\includegraphics[width=4.5cm]{images/rukou2.png}}
    \subfigure[新设计]{\includegraphics[width=4.5cm]{images/dialog1.png}}
    \subfigure[原设计]{\includegraphics[width=4.5cm]{images/dialog2.png}}
    \caption{日常可用性验证实验}
    \label{fig:interface}
\end{figure}

% todo qinxiankang

在技术探针中，用户在进行面部舌部拍照后，没有任何提示。具体的结果需要在用户一次回答13个问题之后，点击诊断才能知道面诊是否成功。
本文在可用性设计上，主要做了以下几点工作:
\begin{enumerate}
    \item 在入口增加的天气相关的上下文信息，推荐适合当前天气的运动。记录用户的诊断历史，保留在诊断列表中。
    \item 在诊断界面设计为类似个人健康看板的布局，通过不同颜色表示症状好坏与严重程度，让用户对自己身体有全面的了解。
    \item 将面诊、舌诊、问诊都设计为可选步骤，避免每次强制面诊舌诊带来尴尬的问题。
    \item 每次进入诊断界面自动加载历史信息，在短时间内用户健康状态变化不大时，只需要回答有变化的问诊问题，避免每次诊断重复的操作。
\end{enumerate}

下面介绍具体实现过程与细节。
%本文在面诊系统上，实现了一个用于对比的原型系统，如图\ref{fig:interface}所示。在该原型系统的首页，有两个入口，新设计和原设计分别对应本文的设计和技术探针的设计，两个设计的功能相同。用户在进入实验原型系统的首页之后，可以自由选择入口，进入对应的界面完成诊断。
%新设计和之前版本的技术探针界面不同的是，诊断界面不仅提供了面诊舌诊问诊的入口，同时会将面诊舌诊的照片和中间结果直接显示在当前页面，用户能对于自己当前身体情况一个直观的感受。

% https://www.xuexila.com/yangsheng/yangshengzhishi/

\subsubsection{迭代过程}
\begin{figure}[h]
    \centering
    \subfigure[设计1]{
        \includegraphics[width=3.5cm]{images/old1.png}
    }
    \subfigure[设计2]{
        \includegraphics[width=3.5cm]{images/old2.png}
    }
    \subfigure[最终设计]{
        \includegraphics[width=4.5cm]{images/ui-1-1.png}
    }
    \caption{新设计迭代过程}
    \label{fig:diag_new}
\end{figure}
在进行可用性设计的过程中，原型系统经历了多次迭代。每次完成一版之后，本文会邀请小部分用户进行试用收集反馈并及时修改。
图\ref{fig:diag_new}展示了部分中间的迭代版本和最终设计，其中设计1中的圆圈代表用户需要回答的问题，圆圈的大小代表影响的权重，权重数值来源自附录\ref{ch:appendix}中所提到的score数组；
设计2简化了界面，统一了圆圈的大小；
最终设计进一步简化了界面元素，并把圆圈改为长方形，方便显示更多的提示信息。

\subsubsection{面诊问诊设计}

\begin{figure}[h]
    \centering
    \includegraphics[]{images/diag_design.png}
    \caption{面诊元素设计}
    \label{fig:diag_design}
\end{figure}

根据日常可用性的设计策略，新设计简化了诊断的流程，面诊舌诊问诊在一个页面显示，并且所有的问题和操作都是可选的，不会出现必须要先面诊然后舌诊然后才能问诊的问题。其次，如图\ref{fig:diag_design}所示，新界面对面诊和舌诊进行了中间结果的反馈，面诊在用户拍照确认之后，会立即报告本次照片是否合格已经诊断的结果，用户不需要在点击诊断的时候才被提示照片不合格。

\subsubsection{问诊元素设计}
在问诊方面，新设计实现了最近一次记录保存，由于问题是可选回答的，所以用户只需要回答和自己上次不一致的结果。

\begin{figure}[h]
    \centering
    \subfigure[上次回答有症状]{
        \includegraphics[width=6cm]{images/question/5.png}
    }
    \subfigure[上次回答无症状]{
        \includegraphics[width=6cm]{images/question/4.png}
    }
    \subfigure[本次回答有症状]{
        \includegraphics[width=6cm]{images/question/2.png}
    }
    \subfigure[本次回答无症状]{
        \includegraphics[width=6cm]{images/question/3.png}
    }
    \subfigure[未回答]{
        \includegraphics[width=6cm]{images/question/1.png}
    }
    \caption{问诊元素的状态}
    \label{fig:question_status}
\end{figure}

同时，如图\ref{fig:question_status}所示，本文对不同问题的回答结果进行了颜色的区分。有色实心代表本次回答，有色空心代表上次回答；橙色代表有症状，绿色代表回答的问题表现良好，没有症状；白色没有填充和边框，为黑字，代表未回答。实心颜色的代表的是用户本次有修改的问诊部分。

在方框内部的问题描述设计上，本文把默认的文字描述，显示为问题描述；一旦用户本次或者上次回答过该问题，则直接显示用户回答的结果。这样做的结果是，第二次用户点进来，就能看到上次的回答结果，这样能够对自己的身体情况有个快速的了解。

\section{设计策略实现2：系统可解释性设计}

\subsection{设计策略}

根据之前的用户研究的结果来看，面诊系统的设计需要考虑以下问题：
\begin{enumerate}
    \item 专业术语带来的理解问题。
    由于当前诊断和打分模型存在改进的空间，部分的用户对结果产生了怀疑或者对结果不理解的问题。同时，日常健康场景下，没有专业医护人员的帮助，普通用户由于缺乏对应的专业知识，对应用的理解还有很大的提升空间。
    \item 系统准确度带来的信赖问题。
    在面诊系统由权威的诊所迁移到日常健康场景后，许多用户对系统的结果持怀疑态度，从而导致他们不信赖系统。在没有其他的评估机制验证结果有效性的前提下，也会让用户对系统产生怀疑。
    \item 诊断结果可视化带来的情绪问题。
    直白地展示诊断结果，特别是系统给出负面结果时，会让用户产生明显的消极情绪并放弃继续使用。
\end{enumerate}


目前提高用户对系统理解程度的方式一般是通过文字、可交互式元素或者可视化的方法描述来暴露算法置信度、暴露中间结果、提供当前数据和原始数据对比等实现\cite{wang2019designing, kocielnik2019will}，
其中文字化的描述适合对系统的背景、或者专业名词进行解释；暴露算法的中间结果以及置信度，能激起用户探索算法原理的好奇心以及提高对结果的容忍程度。
此外，具有自解释的模型如卷积神经网络，attention机制等也是当前研究的热点。

但是，考虑到涉及医疗数据的敏感性，暴露原始数据的方式并不适合在面诊系统中使用。
模型的自解释性并不是当前众多面诊技术的通用属性，本文考虑的是日常健康场景下通用的面诊系统实现，而不是通过强依赖特定模型来实现系统的可解释性。
考虑到一次面诊过程涉及到诸多子过程，最终本文希望通过对诊断过程进行拆分，将模型的诊断过程对用户可见，并使用合适的文字和可交互元素对结果进行解释，来提高用户的交互体验。


不过面诊系统在日常生活中的应用是一个全新的场景，需要解释的对象是什么，通过何种交互元素进行解释，
具体细节如何实现仍是未知的问题，下文将详细介绍该探索过程。


\subsection{可解释设计实现}

在附录\ref{ch:appendix}中本文详细介绍了目前技术探针用的模型，根据本文系统和模型的特点，解释在呈现的时候，实现的解释方法大致可以分为以下几种：
\begin{enumerate}
%  为什么要解释，文字解释的作用。
    \item \textbf{文字描述}。如图\ref{fig:face_diags}所示，结果中文字结果有提示、可以进行点击。如果用户点击了健康报告的分数，会通过弹窗通过文字描述进行详细的解释。

    \item \textbf{可视化元素}。如图\ref{fig:question_weight}所示，通过雷达图的可视化方式直接显示对结果的影响，交互性比较强。雷达图中所用的权重，数值来源自附录\ref{ch:appendix}中所提到的score数组。
    
    \item \textbf{可交互元素}。如图\ref{fig:report_expalin_score}所示，通过可交互元素折叠列表对不同条件下的计算公式进行解释，具体的计算公式可见附录\ref{ch:appendix}中的诊断规则部分。

    \item \textbf{问答系统}。如图\ref{fig:explain_qa}所示，在用户对系统中的医疗专业名词存在疑问或想知道更多医疗知识信息时，可通过问答系统直接询问。
\end{enumerate}

用户在使用系统的过程中，需要经过面诊、舌诊、问诊等流程，最终得到诊断的结果。为本文根据用户研究中用户反馈的问题，对用户完成一次诊断的中间流程以及最终的结果都进行了解释。
为避免影响用户使用，解释界面默认不展示，只有当用户对结果感兴趣或者感到疑惑时，主动点击解释信息才会弹出。

\subsubsection{面诊舌诊的解释}

\begin{figure}[htbp]   
    \centering
    \subfigure[不解释]{\includegraphics[width=4.5cm]{images/face_tongue.png}}
    \subfigure[解释]{\includegraphics[width=4.5cm]{images/exp_face_tongue.png}}
    \subfigure[详细解释]{\includegraphics[width=4.5cm]{images/exp_tongue.png}}
    \caption{面诊舌诊的解释}
    \label{fig:face_diags}
\end{figure}

面诊和舌诊流程比较类似，都是通过分析面部或者舌部图片，得到分析结果，因此这两部分合并放到一起解释。
面诊和舌诊断添加解释主要体现在结果的解释，包括中间结果和对各种体质倾向的影响。
用户查看解释之后，能够大致了解本次拍照是否成功，并且知道目前面诊的结果，以及可能会对最终的健康报告造成哪些影响。具体如图\ref{fig:face_diags}所示：
(a) 没有解释的设计，只能看到结果。
(b) 有解释的设计，通过用户主动点击面诊或者舌诊结果，查看对结果的解释。
(c) 点开解释之后，系统会弹窗进行详细的解释，不仅可以看到当面诊断的中间结果，也能看到这次诊断的体质倾向得分。
接下来介绍该原型中各个解释的细节具体如何实现。


\subsubsection{问诊的解释}

\begin{figure}[htbp]
    \centering
    \subfigure[不解释]{\includegraphics[width=4.5cm]{images/questions.png}}
    \subfigure[解释]{\includegraphics[width=4.5cm]{images/questions2.png}}
    \subfigure[解释体质术语]{
        \includegraphics[width=4.5cm]{images/exp_phy.png}
    }
    \caption{问诊的解释} 
    \label{fig:questions}
\end{figure}

问诊的过程中解释的主要实现，是通过对体质的专业术语和每个答案对结果的影响进行解释，具体实现如图\ref{fig:questions}所示:
\begin{itemize}
    \item 不解释的设计，用户回答问诊问题之后，没有任何提示或者解释。
    \item 有解释的设计，用户在进行问诊过程中，可以立即看到每个答案对结果的影响，通过下方的雷达图显示了影响的体质倾向类型和具体的数值。雷达图的更新是实时根据用户的选择进行更新，用户可以通过点击不同的选项查看不同选项对应的雷达图。
    \item 点开体质的解释之后，会通过弹框的方式，对中医术语中，各种体质的解释。对于体质内容的解释文字引用自《中医体质分类研究》标准。
\end{itemize}

考虑到之前用户研究中有发现用户对不好的结果非常敏感，因此在用户查看每个答案结果时，
系统对于体质倾向的文字描述本文采用了模糊化处理，如将体质描述中的\myfont{肾虚}显示为\myfont{有点肾虚}等。


\subsubsection{诊断结果的解释}
\begin{figure}[htbp]
    \centering
    \subfigure[不解释]{
        \includegraphics[width=4.5cm]{images/report.png}
    }
    \subfigure[解释]{
        \includegraphics[width=4.5cm]{images/report3.png}
    }
    \caption{诊断结果的解释}
    \label{fig:exp_result}
\end{figure}

诊断结果的解释主要是对结果的判断依据和相关原理进行解释，具体如图\ref{fig:exp_result}所示：
\begin{itemize}
    \item 在没有解释的设计中，用户在诊断结果页面，可以看到自己的健康分数和体质结果，并且会在后面给出对应的养生建议和实践，但是给出的结果是不可点击的；
    \item 在有解释的设计中，用户可以点击诊断结果，包括面诊结果、舌诊结果，体质、健康分数。用户点击之后，可以通过之后的弹框，看到详细的解释，如点击健康分数之后，可以了解这个分数是根据哪些指标，通过哪一个算法计算过来的。
\end{itemize}

从图\ref{fig:exp_result}可以看出有解释的设计中，用户点击结果后，会通过弹框解释结果。可以点击查看的结果的解释有：面诊舌诊结果的解释，健康分数的解释，体质的解释，接下来分别介绍如何实现。

\subsubsection{健康分数的解释}
问诊结果的解释主要是对用户解释诊断结果是如何计算，以及那些问诊的问题对结果有影响，影响程度多少。

\begin{figure}[htbp]
    \centering
    \subfigure[相关问题]{
        \includegraphics[width=4.5cm]{images/report7.png}
    }
    \subfigure[雷达图]{
        \includegraphics[width=4.5cm]{images/report8.png}
    }
    \subfigure[计算公式]{
        \includegraphics[width=4.5cm]{images/report9.png}
    }
    \caption{健康分数的解释}
    \label{fig:report_expalin_score}
\end{figure}

如图\ref{fig:report_expalin_score}所示，用户点击诊断页面的分数之后，弹窗里会显示分数相关的问题、雷达图和分数计算公式。
% qinxiankang

分数相关问题展示了面诊舌诊对体质分数的影响和问诊对体质分数的影响，无影响的问题则不会显示。
用户每次回答一个问诊的问题，或者进行面诊舌诊断，都会对体质的倾向分数产生一定的影响。在规则系统中，体质倾向分数的变化分两种，一个是分数的累加，另一种是体质倾向分数的清空。
雷达图对体质分数进行了汇总，给用户展示最终个人的体质倾向的结果。
根据规则系统，解释页面的计算公式一共有5种类别。用户具体属于哪个类别，使用哪一套计算公式，是由用户当前的症状的个数来决定的。
最后本文使用选项卡的方式，将所有的打分计算公式全部暴露给用户，并且默认打开当前计算公式的选项卡。

\subsubsection{问答系统的解释}



一方面如本文在用户研究中所发现，由于日常场景下没有专业的医护人员帮助，用户很难理解系统中包含的专业术语，对诊断结果解释的理解也可能存在疑惑；
另一方面在用户研究中也有用户反馈希望通过面诊应用学习到更多关于健康养生的知识。

\begin{figure}[h]
    \centering
    \includegraphics[width=4.5cm]{images/ans2.png}
    \caption{问答系统的解释}
    \label{fig:explain_qa}
\end{figure}

如图\ref{fig:explain_qa}所示，本文提供了一个问答系统的入口，供用户探索和学习健康医疗相关知识。
问答系统的数据，主要来自开源的知识图谱，如果知识图谱中未搜索到对应内容或解析问题失败，则通过请求百度问答的方式返回对应的回答。
问题系统的具体实现将在本章后续的内容中详细介绍。



\section{系统总体设计}
上两小节主要介绍在交互上设计解决可用性和可解释性的问题，
本小节将介绍本文如何在系统设计层面解决本文在上一章发现的技术敏感性问题以及为可解释性设计提供数据基础，相关问题如下：
\begin{itemize}
    \item 屏蔽移动设备间的差异性，降低设备要求。
    \item 系统稳定性问题。
    \item 模型管理与接入问题。
\end{itemize}

总的来说，本文在系统设计上提出了一个通用可拓展的面诊系统设计，并解决了大量用户研究中发现的问题：通过容器技术实现了跨平台服务，解决了设备差异的问题；通过主从节点和节点选举提高了服务稳定性，同时通过诊断任务拆分提高系统整体性能；
在模型管理方面，通过模型池的设计利用有向无环图管理模型接入和依赖，并定义了模型服务化的规范。

\subsection{诊断任务建模}
本文在实现一个诊断系统之前，对诊断任务进行了建模。
诊断任务是管理模型调用的基本单元，诊断任务建模是诊断任务拆解的基础，通过对诊断任务拆解，可以将诊断过程的中间结果暴露出来，方便后续实现可解释性设计。
此外，为实现对各类诊断模型的兼容性，提供一个通用的系统设计，对其进行建模也是必须步骤。

\begin{figure}
    \centering
    \subfigure[单输入输出]{
        \includegraphics[width=6cm]{images/one_input.png}
    }
    \subfigure[多输入单输出]{
        \includegraphics[width=6cm]{images/two_input.png}
    }
    \subfigure[多输出多输出与模型依赖]{
        \includegraphics[width=10cm]{images/model_dag.png}
    }
    \caption{诊断任务有向无环图示例}
    \label{fig:model_dag}
\end{figure}

如图\ref{fig:model_dag}所示，整个诊断任务由一个有向无环图组成，每个节点都是一个对应的独立服务。模型间的顺序与并发执行都由该有向无环图定义，后续增加删除模型也非常方便。同时节点拆分的设计，可以实现节点级的缓存，提高系统的效率。

整个有向无环图有若干运算节点和两个特殊的节点：input节点与merge节点，其说明如下：
\begin{itemize}
    \item input节点。input节点用于保存用户的原始输入信息，同时触发有向无环图开始执行。
    用户在使用面诊系统的过程中，通常都是一步一步地传入自己信息。
    多个input节点的设计，可以在用户面诊的过程中，动态地执行图中的部分节点，而不是要等待所有输入完成之后再执行。
    此外，input节点还负责用户输入的处理，用于兼容不同输入设备的输入，理论上可以兼容各类不同的硬件输入设备。

    \item merge节点。merge节点用于采集上游节点的输出，并将结果进行合并。
    merge节点可以兼容多输出的场景，在系统需要多个输出的时候，可以把输出节点的叶子节点加上merge节点，merge节点负责将这些结果汇总。

    \item model节点。提供具体的计算能力，根据输入数据，处理完成之后得到具体的输出。
\end{itemize}

\subsubsection{拓扑结构定义}
模型和模型之间的依赖关系决定了图的拓扑结构，其中：(1)input节点无上一级节点。(2)如A模型依赖B模型的输出作为输入，则A模型为B模型的下一级节点。(3)图最后一级节点为merge节点，产出最终结果。

根据拓扑结构，最简单的拓扑结构如图\ref{fig:model_dag}-(a)所示，诊断模型只有一个输出，返回一个输出，目前大部分面诊系统都可以抽象成这种结构，如面诊仪、舌诊仪这类系统。
对于需要提供面部信息、舌部信息多个输入的面诊系统，其拓扑结构如图\ref{fig:model_dag}-(b)所示，节点需要接受多个输入才能执行。
而对于其他设计多个过程的诊断模型以及可拆分的诊断模型，则可将其诊断任务抽象为如图\ref{fig:model_dag}-(c)所示的多输入多输出带有依赖的拓扑结构。

\subsubsection{执行过程}

从整体上看，系统在收到请求后，生成带taskId的input节点，顺序触发所有input节点。从执行逻辑上，input节点执行后，开始触发与input节点直接关联的model节点，无依赖关系的model节点并发执行，有依赖关系的model节点由上一级节点触发。
但在多输入多输出的拓扑结构中，当前节点执行结束之后，可能会有多个依赖的下游节点，而下游节点也可能需要多个上游节点全部完成才能执行，采用上游节点主动触发下游节点的方式逻辑比较复杂。

本文在具体实现中，为了兼容多输入多输出的拓扑结构，
判断是否执行是由当前节点判断上一级节点状态实现，执行图的过程由节点成功处理结束后异步回调触发。
当系统收到回调后，遍历所有未完成任务，判断如果改节点上游全部已完成，则获取上游输入执行该节点，处理结束。

这样设计的好处在于只有节点结束之后发起回调后系统才会遍历节点，不用维护一个定时任务持续遍历判断节点状态，降低了资源消耗。


\subsection{系统模块设计}
为适应各种类型的面诊技术和交互设计，如图\ref{fig:system}所示，系统的分层设计从下往上分别为运行环境、持久化、计算层、客户端、交互设计五个部分。

\begin{figure}
    \centering
    \includegraphics[width=15cm]{images/server8.png}
    \caption{通用可拓展的面诊系统整体模块设计}
    \label{fig:system}
\end{figure}


第一层是运行环境层。考虑到面诊系统需要兼容各种面诊技术，系统整体运行在容器环境下，由Docker和K8s提供对服务间的资源隔离与管理。

第二层是持久化层。系统主要使用MySQL作为持久化工具，通过Redis提供缓存加速，统一的配置中心提供诊断任务有向无环图的在线更新。
如模型输出为大文件，为避免多次在节点间的传输，通过接入对象存储服务(OSS)提供大文件存储和一些文件预处理能力。

第三层是计算层。日志与第三方问卷的接入方便技术探针获取数据，服务端与模型池完成主要的诊断功能。
服务端按功能划分为主节点与多个从节点，主节点接受用户的请求完成任务的拆分与分配，由从节点调用模型池中的模型服务完成诊断。
模型池是对各类可用模型的解耦，对外提供了统一的模型路由、节点缓存和模型管理。

第四层是客户端层。通过跨平台框架MUI，提供统一的客户端实现。
客户端包括Android、IOS和Web平台的客户端，与用户交互密切相关，负责提供一些公共功能如用户面诊的流程以及数据上传，通过请求服务端的接口完成面诊和记录用户的操作信息等。

第五层是交互设计层。系统在各客户端预留了可配置的交互实现接口，通过参数配置可快速切换到不同的交互设计实现，目前提供了日常可用性设计与可解释性设计。


%服务端通过调用模型池的相关服务，为客户端提供接口服务。同时，服务端节点会通过角色竞选和心跳包鉴活机制确定主节点用于分配任务和持久化任务结果，从节点负责执行子任务。
%模型池是指在容器环境下通过容器服务化的方式下所有可用的模型服务的统称，为服务端提供计算服务，完成面部图片分析，舌部图片分析等任务。
%模型池对外提供了统一的模型管理，模型节点的缓存与维护对外的模型路由。
%大多数模型格式为二进制可执行文件或者本地模型文件的形式，为了方便服务端调用，需要对其进行服务化。
%服务化指的就是将算法模型，打包成可调用的服务。其中本文的模型服务化通过Flask框架实现，每一个模型的服务都可以对应服务端中的一个计算任务。
%服务端在任务管理模块中定义了任务的输入输出格式，模型池中的服务需要保持格式一致以确保服务端能够顺利调用对应的模型服务。
%
%一次诊断的大致流程如下：用户通过客户端，上传图片或者回答问题，客户端则向服务端发起请求。
%服务端收到请求之后，进行任务分配，对分配到任务的服务端实例，调用模型池中对应的模型完成特征提取或诊断打分，同时将数据持久化到MySQL为可解释交互提供数据，然后把结果返回给客户端。
%客户端收到服务端的结果后，进行结果的展示。

\section{模型池}
\label{sec:model_pool}
% 什么是模型池
本文提出一个模型池的概念将面诊模型与服务端解耦。

模型池的设计，是为了将模型和服务端独立，方便以后添加或删除模型，同时使系统不局限于当前的诊断模型，方便系统拓展应用其他面诊技术。
此外，将模型独立做成服务，可以动态增加模型运行的实例个数，提高计算能力和稳定性。
在功能点方面，模型池对外提供了统一的模型管理，模型路由和服务化规范。

\subsection{模型服务化及规范}
为了方便模型管理，本文将模型和客户端服务端独立出来，打包成独立可运行的服务。

Flask\footnote{https://palletsprojects.com/p/flask/}是一个基于Python语言的轻量级Web框架，开发者通过极少的代码可以快速实现一个Http服务。服务化的过程是通过Flask框架建立一个Http的服务，把特征提取模型打包成服务。

为兼容各类型面诊模型，本系统对模型服务化的定义规范如下：
\begin{enumerate}

    \item 服务配置中提供服务类型和回调地址。

    \item 每个模型池中的服务，接受http的请求，对传过来的数据进行计算。

    \item 每个请求通过路由规则找到需要请求的模型服务。

    \item 模型服务根据模型计算能力的不同，需要具体独立实现。在实现服务的时候，为了减少服务之间读写的竞争，模型池中的服务只进行计算，不进行对MySQL和Redis的读写，结果的持久化由服务端统一完成。

    \item 服务的内部逻辑需要把服务设计成无状态：如果模型计算需要创建临时文件，计算结束需要删除临时文件。

    \item 使用json作为通讯格式，方便模型服务与系统快速接入，模型输出通过json直接返回或请求服务端回调写入。
\end{enumerate}

\subsection{模型路由}

服务路由是模型池提供的模型统一访问入口。
\begin{lstlisting}[language={C}, title=模型统一访问入口, label={lst:service-json}, basicstyle=\normalsize]
[
{
    "name":"face",
    "cluster_ip": "https://server_address:32200",
    "callback":"https://server_address/callback",
    "timeout": "600000",
    "interval": "200",
    "sync": false
}, 

{
    "name": "tongue",
    "cluster_ip": "https://server_address:32201",
    "callback":"https://server_address/callback",
    "timeout": "600000",
    "interval": "200",
    "sync": false
},
//...
]
    
\end{lstlisting}

% 如何实现的
如以上代码块所示，模型池提供一个<模型类型, cluster ip>的映射，记录可用的模型和调用地址，cluster ip是由K8s提供的集群调用地址，该数据通过json的格式保存在分布式存储中。
其中sync参数代表是否同步返回结果，如果设置成异步返回，则通过调用callback地址将结果回调给服务端，服务端收到回调之后保存结果。
timeout字段用于预先设置服务的超时时间，由于不同的服务计算时间不同，可以根据模型的实际运行速度进行调整。
interval字段表示失败或者超时的重试间隔，默认设置为200毫秒。

服务的稳定性和高可用需要做到服务之间相互独立和多实例同时运行，模型服务使用Docker进行打包，通过K8s管理多个模型高实现可用。
服务端通过K8s提供的cluster ip进行调用，这样能保证在大量用户同时请求模型服务时，某个模型服务如果出错，集群中的其他模型服务能够响应请求。


\section{服务端}

服务端在设计上允许有多个服务端实例同时运行，共同处理用户发起的诊断任务，使用Redis和MySQL进行数据的持久化。

服务端的主要模块如图\ref{fig:server}所示，任务管理为客户端提供了任务提交和结果查询接口，为客户端的面诊、舌诊、问诊提供支持。
系统通过设置定时器，定期地发送心跳包进行主从竞选，主节点会进行任务分配，主节点和从节点则对分配到的任务进行执行，调用模型池中对应的模型服务完成任务。


\begin{figure}[ht]
    \centering
    \includegraphics[width=12cm]{images/server7.png}
    \caption{服务端主要模块设计}
    \label{fig:server}
\end{figure}


\subsection{任务处理}
一次用户诊断，服务端需要完成多个任务，目前支持的任务可以大致分类两类，计算任务和诊断任务。


\subsubsection{计算任务}
\begin{table}[]
    \centering
    \caption{任务表}
    \begin{tabular}{lll}
        \toprule
        字段 & 类型 & 描述 \\ 
        \midrule
        id & int & 主键 \\
        type & int & 任务类型: 面部、舌部、诊断、合并 \\ 
        extra & json & 模型相关信息 \\
        in & text & 任务输入 \\
        out & text & 任务结果 \\
        handler & text & 分配的服务端 \\
        status & int & 任务状态: 新建、已分配、处理中、失败、完成 \\
        createTime & datetime & 创建时间 \\
        updateTime & datetime & 更新时间\\
        \bottomrule
    \end{tabular}
    \label{tab:task}
\end{table}
计算任务对用户的输入进行计算，背后通过模型池中的模型来完成计算，如：面部特征提取任务，舌部特征提取任务，问诊任务。

服务端在收到用户提交的任务之后，会将数据存储到数据库的task表中，task表的主要字段如表\ref{tab:task}所示：
\begin{enumerate}
    
    \item type一共有四种取值，目前对应四种任务类型：面部特征提取任务、舌部特征提取任务、诊断任务和合并任务。

    \item in为任务的输入，其中面部特征提取和舌部特征提取任务需要的输入为图片，通过Base64编码序列化为json对象，保存在in字段中。

    \item out为任务的执行结果，在模型池的服务完成计算之后，服务端将任务执行结果保存到out字段，同时更新任务的状态。

    \item  handler保存当前任务是由哪个服务端在负责处理。

    \item extra通过json格式存储模型相关信息，如分类任务，如体质判别，输出的8种体质\footnote{7种体质倾向，如无任何倾向则为健康}的中文名称，保存在extra中。
\end{enumerate}

\subsubsection{诊断任务}
% 合并任务只有前置任务，没有后置任务，它是整个任务调度流程中的最后一个任务。合并任务的主要功能是在所有计算类型的任务完成后，对计算出来的结果进行合并。

% 合并任务的触发时机，是在合并任务的所有前置任务完成之后。合并任务的合并流程如下：

诊断任务的执行逻辑在服务端实现，不在模型池中有对应的模型。诊断任务用于监测整个图的顺利执行。

在各类任务完成之后，诊断任务通过从Redis或者MySQL中获取当前已完成任务的结果作为输入，完成最终的诊断。诊断任务的内部实现是有一套规则系统组成，定义了每一个任务的输入，会对最终的输出产生怎么样的影响。

在该模式下，本地系统可以比较方便的添加新的模型： 在一个新的模型添加到模型池之后，只需要在规则系统中，添加一条新的规则即可完成模型的接入。
这样，新模型可以通过规则系统中设置的规则，影响最终的结果。

\begin{figure}[ht]
    \centering
    \includegraphics[width=12cm]{images/sketch3.png}
    \caption{诊断流程}
    \label{fig:sketch}
\end{figure}

诊断流程具体如图\ref{fig:sketch}所示：用户在提交诊断任务之后，服务端会将诊断任务分解成多个小的计算任务，其中包括面部特征提取，舌部特征提取以及其他相关的任务。任务分解的目的是降低单个服务端实例的计算压力，将任务计算分发到多个服务端，提高计算速度。
同时分解后的任务结果都保存在MySQL数据库中，便于后续算法暴露中间结果给用户。
在任务分解之后，通过轮询选出其中一个未完成的任务，调用相关服务完成计算；如果计算任务事先已经完成计算，或者经过轮询已经完成所有的任务，则通过规则系统，取出计算任务的结果进行诊断。



\subsection{任务分配}
%为什么要这样做？
为了实现服务的稳定性，服务端支持同时开启多个实例，即多个服务端同时处理任务。
同时考虑到性能，服务端设计为读写分离的架构：每个实例都可以读取任务列表，处理用户的任务，但只有主节点有任务分配的权限。


\subsubsection{主从节点}
% 为什么要这样做
为了屏蔽用户间的设备差异，让硬件较差的用户设备也能调用模型，本系统采用算法模型和客户端剥离的方案。
模型和客户端剥离则增加了服务端的计算压力，对系统稳定性要求更高。
虽然目前已有大量成熟的服务发现、服务注册相关的框架，但为了使服务尽量轻量化，避免引入更多的依赖，简单的主从机制已经可以满足需要。
因此服务端通过实现简单的读写分离和主从竞选的机制，使得服务端支持同时运行多个实例，提高稳定性和性能。

大批量的用户请求需要服务的高可用。为了实现服务端的高可用，本文将服务端设计成允许多个实例同时运行。同时，如果不做主从节点划分，每次有可用的任务时，所有节点都去抢占任务，会有大量锁的竞争的问题。
因此本文将每个实例的角色划分为主节点和从节点进行读写分离，不同节点的具体职责如下：
\begin{enumerate}
    \item 主节点： 通过任务的id进行哈希，按照哈希进行任务的分配给各个节点，更新任务表。分配任务时，只有主节点才有对任务表进行写操作的权限。

    \item 从节点： 每个从节点每过一定的间隔时间，就会去读取任务列表，开始执行任务列表里属于自己的任务。

\end{enumerate}

基于此机制，服务的实现任务分配只由主节点去更新任务表，而执行任务时每个节点只会执行分配给自己的任务。

\subsubsection{角色竞选流程}

\begin{figure}
    \centering
    \includegraphics[width=10cm]{images/slave-master.png}
    \caption{服务端角色竞选}
    \label{fig:slave_master}
\end{figure}

服务端通过主从节角色分配的方式，同时运行多个实例来提高系统的响应速度，但多个实例同时运行也带来了系统稳定性的问题，如节点因为网络问题或者其他问题失效时，则需要通过心跳包探测节点存活。

服务端通过心跳包探活，主节点失效时，通过Redis的分布式锁实现主节点的竞选。

每个节点在启动之后，会在本地把自己的角色默认设置成从节点。
然后每过一段时间，判断自己节点的类型，主从节点分别执行以下的心跳策略竞选主节点：
\begin{enumerate}
    \item 主节点：主节点每次心跳的时候，更新Redis中主节点的过期时间。如果更新成功，等待下一次心跳； 如果更新失败(更新失败可能是自己没有及时更新，导致Redis里的主节点过期，主节点的身份被其他节点竞争到了)，则把自己的节点类型设置成从节点。
    
    \item 从节点：从节点每次从Redis里获取主节点的信息，如果主节点信息无效或者长时间没有心跳(默认设置为两轮心跳周期)，则开始抢占竞选锁，尝试更新Redis的信息让自己成为主节点；如果Redis的主节点信息已经是本节点，说明上一轮抢占成功，将本节点的角色更新为主节点。
\end{enumerate}

\section{健康知识问答系统}

在用户研究中本文发现：一方面由于用户间文化差异性，日常场景下用户使用面诊技术会出现难以理解系统中健康相关专有名词的问题；
另一方面，用户在使用过程中透露出了学习健康知识的兴趣。知识图谱是目前被广泛使用的描述与管理现有知识的技术，本文基于知识图谱构建一个健康知识问答系统，以满足用户这方面的需求。

\subsection{健康知识获取}

在本文中，知识图谱中知识的获取主要两个方面：(1)从结构化与非结构化的数据源中提取。(2)从现有的开源知识图谱中导入。

\begin{figure}[h]
    \centering
    \subfigure[疾病百科网]{\includegraphics[width=7cm]{images/bk.png}}
    \subfigure[疾病百科网详情页]{\includegraphics[width=7cm]{images/bk_detail.png}}
    \caption[]{结构化数据源}
    \label{fig:source}
\end{figure}

如图\ref{fig:source}所示，获取知识的数据源如在线网站，可分为结构化与非结构化两种类型。
如图\ref{fig:source}-(a)所示，疾病百科网\footnote{https://jbk.39.net/}是一个关于各类疾病介绍的百科网站，其首页整理了各种归类后的疾病介绍入口，
这些疾病将在知识图谱中以实体的方式存储。如图\ref{fig:source}-(b)所示，疾病百科网在详情页则描述了某类疾病的具体信息，如治疗方法、基本信息等，这些将在知识图谱中以实体的属性和属性值的方式存储。

由于结构化的数据源有固定的结构，本文在获取这类数据时，首先通过爬虫在首页获取所有详情页相关的url存储到本地，然后读取url列表将这些url对应的html文件下载到本地，最后一次读取html文件，
利用html解析工具按css选择器、xpath等方式定位需要提取的内容，以三元组的方式保存到本地。

\begin{figure}[h]
    \centering
    \includegraphics[width=15cm]{images/msj.png}
    \caption[]{美食杰}
    \label{fig:rel_source}
\end{figure}
如图\ref{fig:rel_source}所示，美食节网\footnote{https://www.meishij.net/}是一个关于各类介绍菜谱美食相关信息的网站，
其中也有各种体质调理、饮食常识相关的板块，但其页面内容是以非结构化的方式展示的。对于这类数据源，本文定义了特定的正则表达式匹配文章的标题，
如\myfont{.*应该吃什么.*}、\myfont{.*不能吃什么.*}等表达式匹配需要的文章的url，通过url把对应的html文件下载到本地，然后将文章内容作为属性值保存为三元组数据。

保存原始html的目的，是为了方便以后提取更多其他目前没有用到的信息时避免重复爬取，同时为未来可能的信息推送提供数据基础。
最后，在获取到三元组数据后，通过脚本将数据导入到neo4j数据库中。


健康相关的开源知识图谱，如中国中医科学院中医药信息研究所提供的中医养生知识图谱\footnote{http://www.tcmkb.cn/kg}、医药领域知识图谱\footnote{https://github.com/CuiZhengliang/QASystemOnMedicalKG}等，
其中包含了各类疾病、食物相关知识数据，主要以owl、json文件的等格式保存。
其中owl格式文件通过neosemantics\footnote{https://github.com/neo4j-labs/neosemantics}工具导入到neo4j中、json格式文件通过脚本方式写入neo4j中。

\begin{figure}[h]
    \centering
    \includegraphics[width=12cm]{images/brower.png}
    \caption[]{数据导入可视化}
    \label{fig:brower}
\end{figure}

最终经过筛选，如图\ref{fig:brower}所示，本文最终导入了健康知识相关的2万余实体与15万余关系作为实现健康知识问答的数据基础。

\subsection{意图识别与实体识别}

意图识别与实体识别是指从自然语言中提取其中包含的实体以及语句的意图，是从知识图谱中获取数据的基础。如一个自然语言形式的查询\myfont{我想知道阳虚有哪些症状？}，
其中\myfont{阳虚}为实体，\myfont{查询症状}为实现定义的意图。

知识在知识图谱中以三元组的方式表示，如<实体，关系，实体>、<实体，属性，属性值>，分别对应图数据库中的<点，边，点>和<点，属性，属性值>。
自然语言经过意图识别与实体识别，便可转化为图数据库中对点的属性查询，如\myfont{我想知道阳虚有哪些症状？}对应查询为\myfont{查询节阳虚节点的症状属性}。

本文采用了Rasa框架\footnote{https://rasa.com/docs/rasa/}完成意图识别与实体识别。Rasa框架一个开源的聊天机器人框架，提供了信息理解(Rasa NLU)和会话管理(Rasa Core)两个基本模块，使用者可以配置快速完成一个问答系统的搭建。

由于手动生成Rasa框架的训练集比如费时，本文使用了chatito框架批量生成rasa的训练数据。chatito是一个生成自然语言理解数据集的工具，支持多种格式，其中就包括rasa。
chatito的语法支持在语料模板中定义各类意图、实体、同义词，并且可以配置训练集与测试集的比例，本文定义的部分语料模板如下：
\begin{lstlisting}[label=lst:chatito, caption={chatito部分语料模板配置}, basicstyle=\normalsize]
import disease.chatito
import common.chatito

%[intention_ask_symptom]('trainning': '85', 'testing': '15')
    我想知道@[disease]的~[症状]有哪些
    @[disease]的~[症状]是什么

%[intent_ask_not_eat]('trainning': '100')
    我想知道@[disease]~[否定]吃什么
    @[disease]~[否定]不能吃什么
    @[disease]~[否定]忌吃什么

%[intent_ask_eat]('trainning': '100')
    我想知道@[disease]吃什么
    @[disease]吃什么
...
\end{lstlisting}

在配置上，使用预训练的模型\footnote{https://github.com/mit-nlp/MITIE}作为词向量(Word Embedding)，使用开源的Jieba分词\footnote{https://github.com/fxsjy/jieba}作为分词工具，
通过将neo4j数据库中疾病、食物、症状节点名导出作为配置中的实体名\footnote{为降低问题复杂度，每个查询中只配置了一个实体}，本文最终利用chatito生成了99万条训练数据训练Rasa NLU模型，训练数据格式如下:

\begin{lstlisting}[caption={Rasa NLU训练数据}, label={lst:train-data}, basicstyle=\normalsize]
{"text":"原发性骨淋巴瘤忌不能吃什么",
    "intent":"intent_ask_not_eat",
    "entities":[
        {"end":7,"entity":
        "disease","start":0,
        "value":"原发性骨淋巴瘤"}
    ]
},
{"text":"眼部神经纤维瘤病忌不能吃什么",
    "intent":"intent_ask_not_eat",
    "entities":[{"end":8,"entity":
        "disease","start":0,
        "value":"眼部神经纤维瘤病"}]},
\end{lstlisting}


\subsection{问答查询过程}

\begin{figure}[h]
    \centering
    \includegraphics[width=15cm]{images/cypher.png}
    \caption{问答查询过程}
    \label{fig:query_process}
\end{figure}

一次完成的用户问答查询过程如图\ref{fig:query_process}所示，以查询疾病症状为例，具体的过程如下:

\begin{enumerate}
    \item 当用户发起询问\myfont{我想知道阳虚的症状是什么}时，Rasa NLU模块会根据预先训练好的模型对语句进行实体识别和意图识别，得到其中的实体为\myfont{阳虚}，意图为\myfont{查询症状}。

    \item Cypher查询生成。Cypher是Neo4j用户查询图数据的查询语言，Cypher查询生成步骤需要将实体与意图构造出对应的Cypher查询语句。根据不同的意图，配置不同的Cypher模板即可实现该功能。

    \item Neo4j执行查询，如图\ref{fig:cypher}所示，通过生成的cypher语句查询Neo4j数据库中名为阳虚的疾病节点对应的症状节点的名称，返回症状名列表。

    \begin{figure}[h]
        \centering
        \includegraphics[width=12cm]{images/query.png}
        \caption{通过cypher查询获取症状列表}
        \label{fig:cypher}
    \end{figure}

    \item 通过预先定义好的模板，将数据拼接成对应的回复，如\myfont{阳虚的主要症状如下：...}。

    \begin{figure}[h]
        \centering
        \includegraphics[width=6cm]{images/qa2.png}
        \caption{用户问答}
        \label{fig:qa}
    \end{figure}

    \item 如图\ref{fig:qa}所示，用户在查询结果后将收到问题答案。如果用户没有收到回复，则通过爬虫爬取百度搜索网页上的结果作为回复，并在回复上注明结果来自百度。

\end{enumerate}



\section{本章小结}
本章介绍了面诊系统的具体实现以解决上一章发现的技术敏感性问题与系统交互问题，其中日常可用性设计实现了简化交互流程，将面诊、舌诊、问诊可选，保留用户历史纪录等机制；
可解释性设计则通过文字性解释、可视化元素、可交互元素、问答系统等机制对系统进行解释。
在后续的系统设计中，则设计了一个较为通用可拓展的面诊系统，并具体的系统设计解决了用户研究中发现的各种问题，提高系统稳定性。